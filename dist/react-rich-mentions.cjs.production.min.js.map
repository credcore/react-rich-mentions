{"version":3,"file":"react-rich-mentions.cjs.production.min.js","sources":["../src/utils/noop.ts","../src/RichMentionsContext.ts","../node_modules/style-inject/dist/style-inject.es.js","../src/utils/nodeToHtmlElement.ts","../src/utils/getFragment.ts","../src/utils/setCursorPosition.ts","../src/utils/escapeFragmentWithValue.ts","../src/utils/deleteSelection.ts","../src/utils/transformFinalFragment.ts","../src/utils/removeBrokenFragments.ts","../src/utils/insertFragment.ts","../src/utils/handleFragmentDeletion.ts","../src/RichMentionsAutocomplete.tsx","../src/RichMentionsInput.tsx","../src/RichMentionsProvider.tsx","../src/utils/getConfigsInitialValue.ts","../src/utils/fixCursorInsertion.ts","../src/utils/handleFragmentEscape.ts","../src/utils/handleFragmentCreation.ts","../src/utils/getTransformedValue.ts"],"sourcesContent":["export const noop = () => {};\n","import { createContext } from 'react';\nimport { noop } from './utils/noop';\n\nexport type TMentionItem<T = object> = T & {\n  name: string;\n  ref: string;\n};\n\nexport interface TMentionConfig<T = object> {\n  query: RegExp;\n  match: RegExp;\n  matchDisplay: string;\n  customizeFragment?: (fragment: HTMLSpanElement, final: boolean) => void;\n  onMention: (\n    text: string,\n    callback?: (results: TMentionItem<T>[]) => void\n  ) => void | TMentionItem<T>[] | Promise<TMentionItem<T>[]>;\n}\n\nexport interface TMentionContext {\n  getTransformedValue: () => string;\n  setValue: (text: string) => void;\n  insertFragment: (ref: string, element?: HTMLElement) => void;\n  activeSearch: string;\n  inputElement: HTMLDivElement | null;\n  setInputElement: (newInputElement: HTMLDivElement | null) => void;\n  selectItem: (item: TMentionItem<any>) => void;\n  setActiveItemIndex: (index: number) => void;\n  opened: null | {\n    config: TMentionConfig<any>;\n    element: HTMLSpanElement;\n    fixed: boolean;\n    bottom: boolean;\n    right: boolean;\n    x: number;\n    y: number;\n  };\n  index: number;\n  loading: boolean;\n  results: TMentionItem<any>[];\n  closeAutocomplete: () => void;\n  openAutocomplete: <T>(\n    node: HTMLElement,\n    value: string,\n    config: TMentionConfig<T>\n  ) => void;\n  onBeforeChanges: (event: React.FormEvent<HTMLDivElement>) => void;\n  onKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n  onChanges: (event: React.FormEvent<HTMLDivElement>) => void;\n  getInitialHTML?: (value: string) => string;\n  fixed: boolean;\n  setPositionFixed: (fixed: boolean) => void;\n}\n\nexport const initialContext: TMentionContext = {\n  getTransformedValue: () => '',\n  insertFragment: noop,\n  setValue: noop,\n  activeSearch: '',\n  inputElement: null,\n  setInputElement: noop,\n  selectItem: noop,\n  setActiveItemIndex: noop,\n  opened: null,\n  index: 0,\n  loading: false,\n  results: [],\n  closeAutocomplete: noop,\n  openAutocomplete: noop,\n  onBeforeChanges: noop,\n  onKeyDown: noop,\n  onChanges: noop,\n  fixed: true,\n  setPositionFixed: noop,\n};\n\nexport const RichMentionsContext = createContext<TMentionContext>(\n  initialContext\n);\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","export function nodeToHtmlElement(node: Node): HTMLElement | null {\n  return node.nodeType === Node.TEXT_NODE\n    ? node.parentElement\n    : (node as HTMLElement);\n}\n","import { nodeToHtmlElement } from './nodeToHtmlElement';\n\nexport function getFragment(node: Node): HTMLElement | null {\n  const element = nodeToHtmlElement(node);\n  return element && element.hasAttribute('data-rich-mentions') ? element : null;\n}\n","export function setCursorPosition(\n  element: HTMLElement | Node | Text,\n  position: number\n): void {\n  const selection = document.getSelection();\n  const range = document.createRange();\n\n  range.setStart(element, position);\n  range.collapse(true);\n\n  if (selection) {\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}\n","import { setCursorPosition } from './setCursorPosition';\n\nexport function escapeFragmentWithValue(\n  element: HTMLElement,\n  text: string,\n  position: 'after' | 'before' = 'after'\n) {\n  const textNode = document.createTextNode(text.replace(/\\s/g, '\\u00A0'));\n  const parent = element.parentElement;\n\n  if (parent) {\n    if (position === 'after') {\n      parent.insertBefore(textNode, element.nextSibling);\n    } else {\n      parent.insertBefore(textNode, element);\n    }\n    setCursorPosition(textNode, text.length);\n  }\n}\n","import { setCursorPosition } from './setCursorPosition';\n\nexport function deleteSelection(\n  selection: Selection,\n  event?: React.FormEvent<HTMLDivElement>\n): boolean {\n  let deleted = false;\n  let lastDeletedRange = null;\n\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    const range = selection.getRangeAt(i);\n\n    if (\n      range.startContainer !== range.endContainer ||\n      range.startOffset !== range.endOffset\n    ) {\n      deleted = true;\n      lastDeletedRange = range;\n      range.deleteContents();\n    }\n  }\n\n  // @ts-ignore\n  if (event?.data && lastDeletedRange) {\n    // @ts-ignore\n    const textNode = document.createTextNode(event.data);\n    lastDeletedRange.insertNode(textNode);\n    setCursorPosition(textNode, 1);\n    event.preventDefault();\n  }\n\n  return deleted;\n}\n","import { TMentionConfig, TMentionItem } from '../RichMentionsContext';\nimport { setCursorPosition } from './setCursorPosition';\n\nexport function transformFinalFragment<T>(\n  span: HTMLSpanElement,\n  ref: TMentionItem['ref'],\n  config: TMentionConfig<T>\n): void {\n  const content = ref\n    .replace(config.match, config.matchDisplay)\n    .replace(/\\s/g, '\\u00A0');\n\n  span.textContent = content;\n  span.setAttribute('data-rich-mentions', ref);\n  span.setAttribute('spellcheck', 'false');\n\n  if (process.env.NODE_ENV !== 'production') {\n    span.setAttribute('data-cy', 'final');\n  }\n\n  if (config.customizeFragment) {\n    config.customizeFragment(span, true);\n  }\n\n  span.setAttribute('data-integrity', span.innerHTML);\n\n  if (span.parentElement) {\n    // TODO only if no space after\n    const textNode = document.createTextNode('\\u00A0');\n    span.parentElement.insertBefore(textNode, span.nextSibling);\n    setCursorPosition(textNode, 1);\n  }\n}\n","import { TMentionConfig } from '../RichMentionsContext';\n\nexport function removeBrokenFragments<T>(\n  inputElement: HTMLDivElement,\n  configs: TMentionConfig<T>[]\n) {\n  Array.from(inputElement.children).forEach(function fixBrokenElement(\n    element,\n    index\n  ) {\n    const parent = element.parentElement as HTMLElement;\n\n    // Replace BR with div>br\n    // There is a bug on chrome occuring when the cursor is just after a br, the selection is broken and\n    // we can't locate its position. By moving them inside a div it fixes the problem\n    if (element instanceof HTMLBRElement) {\n      if (\n        parent.children.length !== 1 &&\n        index !== parent.children.length - 1\n      ) {\n        const div = document.createElement('div');\n        parent.insertBefore(div, element);\n        div.appendChild(element);\n      }\n      return;\n    }\n\n    if (element instanceof HTMLDivElement && !element.attributes.length) {\n      Array.from(element.children).forEach(fixBrokenElement);\n      return;\n    }\n\n    const text = element.textContent || '';\n\n    // Fixes a Chrome bug:\n    // - Add a span with color on a contenteditable.\n    // - Remove the span with backspace.\n    // - Type text.\n    // Chrome will try to restore the style by adding a <font> with specific styles.\n    if (\n      !(element instanceof Text) &&\n      !element.hasAttribute('data-rich-mentions')\n    ) {\n      parent.insertBefore(document.createTextNode(text), element);\n      parent.removeChild(element);\n      return;\n    }\n\n    // On final fragments, avoid edition.\n    // The data-integrity attribute contains the original fragment content.\n    // If it does not match, just remove the entire fragment.\n    if (element.hasAttribute('data-integrity')) {\n      // final fragment, if not valid remove it completely\n      if (element.getAttribute('data-integrity') !== element.innerHTML) {\n        parent.removeChild(element);\n      }\n      return;\n    }\n\n    // If we have a pending fragment that is now invalid since the last (let\n    // say you just removed the '@' from it, then we can safely extract the\n    // text, remove the fragment, and insert the text back without it.\n    const isValid = configs.some(cfg => text.match(cfg.query));\n    if (!isValid) {\n      parent.insertBefore(document.createTextNode(text), element.nextSibling);\n      parent.removeChild(element);\n    }\n  });\n}\n","import { getFragment } from './getFragment';\nimport { deleteSelection } from './deleteSelection';\nimport { setCursorPosition } from './setCursorPosition';\nimport { transformFinalFragment } from './transformFinalFragment';\nimport { TMentionConfig } from '../RichMentionsContext';\nimport { removeBrokenFragments } from './removeBrokenFragments';\n\nconst isSpace = (char: string) => /(\\u00A0|\\s)/.test(char);\n\nconst needSpaceBefore = (\n  text: string,\n  offset: number,\n  node: Node,\n  defaultValue: boolean\n): boolean => {\n  if (offset > 0) {\n    return !isSpace(text.charAt(offset - 1));\n  }\n\n  // Do not add space if the previous element is a block adding a line break\n  if (['DIV', 'BR'].includes(node.nodeName)) {\n    return false;\n  }\n\n  if (node.previousSibling) {\n    // TODO get first previous element with text\n    const prevText = node.previousSibling.textContent || '';\n    return !!prevText.length && !isSpace(prevText.charAt(prevText.length - 1));\n  }\n\n  return defaultValue;\n};\n\nconst needSpaceAfter = (text: string, offset: number, node: Node): boolean => {\n  if (offset < text.length) {\n    return !isSpace(text.charAt(text.length - 1));\n  }\n\n  if (!node.nextSibling) {\n    return true;\n  }\n\n  const nextText = node.nextSibling.textContent || '';\n  // TODO get first next fragment with content...\n  return !nextText.length || !isSpace(nextText.charAt(0));\n};\n\nexport function insertFragment<T>(\n  ref: string,\n  customFragment: HTMLElement | null,\n  configs: TMentionConfig<T>[],\n  inputElement: HTMLDivElement | null\n) {\n  const config = configs.find(cfg => ref.match(cfg.match));\n\n  // inputElement was removed from DOM for some reasons\n  if (!inputElement || (!config && !customFragment)) {\n    return;\n  }\n\n  let insertAfterNode: Node | null = null;\n  let insertBeforeNode: Node | null = null;\n  let addSpaceBefore = false;\n  let addSpaceAfter = false;\n\n  const selection = document.getSelection();\n\n  // Is selection inside inputElement ?\n  // (avoid inserting fragments on other parts of the website)\n  if (\n    selection &&\n    selection.anchorNode &&\n    inputElement.contains(selection.anchorNode)\n  ) {\n    let { anchorNode: node, anchorOffset: offset } = selection;\n    let fragment = getFragment(node);\n\n    // Avoid problem with text selection\n    // Just delete it before processing\n    deleteSelection(selection);\n\n    // If we are at the fragment end when inserting content, we have to\n    // change the cursor position to be at first position on the next one.\n    // If the next fragment does not exist, add a new one.\n    // <span>\"text\"|<span>   -> <span>\"text\"</span>\"|\"\n    if (fragment && offset === (node.textContent || '').length) {\n      if (!fragment.nextSibling) {\n        inputElement.insertBefore(document.createTextNode(''), null);\n      }\n      node = fragment.nextSibling as Node;\n      offset = 0;\n      fragment = null;\n    }\n\n    if (fragment) {\n      // Final fragment can't be edited\n      // Just remove it and add the insertion just after.\n      if (fragment.hasAttribute('data-integrity')) {\n        insertBeforeNode = fragment.nextSibling;\n        fragment.parentElement?.removeChild(fragment);\n      } else {\n        const text = node.textContent || '';\n\n        // In this case, we are in the middle of a pending fragment.\n        // <span>@vin|ce</span> -> <span>@vin</span>\" [insertion] \"ce\"\n        if (offset > 0 && offset < text.length) {\n          const firstPart = text.substr(0, offset);\n          const secondPart = text.substr(offset);\n          const subFragment = document.createTextNode(secondPart);\n\n          inputElement.insertBefore(subFragment, fragment.nextSibling);\n          node.textContent = firstPart;\n          addSpaceBefore = true;\n          insertBeforeNode = subFragment;\n        }\n\n        addSpaceBefore = needSpaceBefore(text, offset, node, addSpaceBefore);\n        addSpaceAfter = needSpaceAfter(text, offset, node);\n      }\n    } else {\n      // Text inside the contenteditable (not nested)\n      let text = node.textContent || '';\n\n      // If we are at the first position in a fragment, we need to insert the new\n      // fragment before it, not after.\n      if (offset > 0) {\n        insertAfterNode = node;\n      } else {\n        // If next block is <div><br/></div> we have to replace it to a single <div></div>\n        const element = node as HTMLElement;\n        if (\n          !text &&\n          element.nodeName === 'DIV' &&\n          !element.attributes.length &&\n          element.childNodes.length === 1 &&\n          element.firstElementChild instanceof HTMLBRElement\n        ) {\n          if (element.previousSibling instanceof HTMLDivElement) {\n            insertBeforeNode = node;\n            element.removeChild(element.firstElementChild);\n          } else {\n            insertAfterNode = node;\n            element.removeChild(element.firstElementChild);\n          }\n        } else {\n          insertBeforeNode = node;\n        }\n      }\n\n      // In this case, we need to add the insertion at the center of a TextNode.\n      // Let say we have \"hello|world\", as you can't add span inside TextNode, we have\n      // to split it in two differents nodes : \"Hello\" and \"world\", and insert the span\n      // between them.\n      if (offset > 0 && offset < text.length) {\n        const firstPart = text.substr(0, offset);\n        const secondPart = text.substr(offset);\n\n        text = firstPart;\n        node.textContent = firstPart;\n\n        node.parentElement?.insertBefore(\n          document.createTextNode(secondPart),\n          node.nextSibling\n        );\n      }\n\n      addSpaceBefore = needSpaceBefore(text, offset, node, addSpaceBefore);\n      addSpaceAfter = needSpaceAfter(text, offset, node);\n    }\n  } else {\n    // Can't find the selection, let's just insert the fragment at the\n    // end of the div[contenteditable]\n    const text = inputElement.textContent || '';\n    addSpaceAfter = true;\n    addSpaceBefore = !isSpace(text.charAt(text.length - 1));\n  }\n\n  // Create fragment\n  const span = document.createElement('span');\n  if (config) {\n    transformFinalFragment(span, ref, config);\n  } else if (customFragment) {\n    span.appendChild(customFragment);\n    span.setAttribute('data-rich-mentions', ref);\n    span.setAttribute('data-integrity', span.innerHTML);\n    span.setAttribute('spellcheck', 'false');\n\n    if (process.env.NODE_ENV !== 'production') {\n      span.setAttribute('data-cy', 'final');\n    }\n  }\n\n  // Insert it at chosen position\n  if (insertAfterNode && insertAfterNode !== inputElement) {\n    insertAfterNode.parentElement?.insertBefore(\n      span,\n      insertAfterNode.nextSibling\n    );\n  } else if (insertBeforeNode && insertBeforeNode !== inputElement) {\n    insertBeforeNode.parentElement?.insertBefore(span, insertBeforeNode);\n  } else {\n    inputElement.appendChild(span);\n  }\n\n  // Insert space before if needed\n  if (addSpaceBefore) {\n    const space = document.createTextNode('\\u00A0');\n    span.parentElement?.insertBefore(space, span);\n  }\n\n  // Insert space after if needed\n  if (addSpaceAfter) {\n    const space = document.createTextNode('\\u00A0');\n    span.parentElement?.insertBefore(space, span.nextSibling);\n  }\n\n  // Set cursor position (always true)\n  if (span.nextSibling) {\n    setCursorPosition(span.nextSibling, addSpaceAfter ? 1 : 0);\n  }\n\n  // If the user is selecting text and some parts of fragment, we need to be sure to delete it correctly\n  // Ex where \"[\" and \"]\" are the start and ending of text selection:\n  // input: \"he[llo <span>@vin]ce</span>\"\n  // output: \"he @insertedfragment <span>ce</span>\"\n  // In this case, the fragment \"ce\" need to be deleted.\n  removeBrokenFragments<T>(inputElement, configs);\n}\n","import { nodeToHtmlElement } from './nodeToHtmlElement';\n\nconst removeIfFinalFragment = (node: Node, container: HTMLDivElement): void => {\n  const element = nodeToHtmlElement(node);\n  if (!container.contains(element) || container === element) {\n    return;\n  }\n\n  if (element && element.hasAttribute('data-integrity')) {\n    container.removeChild(element);\n  }\n};\n\nexport function handleFragmentDeletion(\n  event: React.FormEvent<HTMLDivElement>,\n  selection: Selection\n): void {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const container = event.currentTarget;\n\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n\n    removeIfFinalFragment(range.startContainer, container);\n    removeIfFinalFragment(range.endContainer, container);\n  }\n}\n","import React, { useContext, useEffect } from 'react';\nimport { RichMentionsContext, TMentionItem } from './RichMentionsContext';\n\ninterface TProps {\n  fixed?: boolean;\n  className?: string;\n  selectedItemClassName?: string;\n  itemClassName?: string;\n}\n\nexport function RichMentionsAutocomplete<T = object>({\n  fixed = true,\n  className,\n  itemClassName,\n  selectedItemClassName,\n}: TProps) {\n  const {\n    opened,\n    index,\n    //loading,\n    results,\n    setActiveItemIndex,\n    selectItem,\n    setPositionFixed,\n  } = useContext(RichMentionsContext);\n\n  const onSelectItem = (item: TMentionItem<T>) => () => selectItem(item);\n  const onHoverItem = (index: number) => () => setActiveItemIndex(index);\n  const divAttributes =\n    process.env.NODE_ENV !== 'production' ? { 'data-cy': 'autocomplete' } : {};\n  const itemAttributes =\n    process.env.NODE_ENV !== 'production'\n      ? { 'data-cy': 'autocomplete_item' }\n      : {};\n\n  useEffect(() => {\n    setPositionFixed(fixed);\n  }, [fixed, setPositionFixed]);\n\n  return opened && results.length ? (\n    <div\n      {...divAttributes}\n      className={`${className}`}\n      style={{\n        position: fixed ? 'fixed' : 'absolute',\n        left: opened.x + 'px',\n        top: opened.y + 'px',\n      }}\n    >\n      <div\n        className=\"autocomplete-list\"\n        style={{\n          bottom: opened.bottom ? '0px' : 'auto',\n          right: opened.right ? '0px' : 'auto',\n        }}\n      >\n        {results.map((item, i) => (\n          <button\n            className={`${itemClassName} ${\n              i === index ? selectedItemClassName : ''\n            }`}\n            type=\"button\"\n            key={item.ref}\n            onClick={onSelectItem(item)}\n            onMouseOver={onHoverItem(index)}\n            {...itemAttributes}\n          >\n            {item.name}\n          </button>\n        ))}\n      </div>\n    </div>\n  ) : null;\n}\n","import React, { HTMLProps, useRef, useContext, useState } from 'react';\nimport { RichMentionsContext } from './RichMentionsContext';\n\nimport styles from './RichMentions.module.css';\n\ninterface TProps extends HTMLProps<HTMLDivElement> {\n  defaultValue?: string;\n  singleLine?: Boolean;\n  placeholder?: string;\n  className?: string;\n  onEnter?: () => void;\n}\n\nexport function RichMentionsInput({\n  defaultValue,\n  singleLine,\n  placeholder,\n  className,\n  onEnter,\n  ...divAttributes\n}: TProps) {\n  const ref = useRef<string | null>(null);\n\n  const {\n    setInputElement,\n    onBeforeChanges,\n    onKeyDown,\n    onChanges,\n    getInitialHTML,\n    opened,\n    getTransformedValue,\n  } = useContext(RichMentionsContext);\n  const [isEmpty, setEmpty] = useState(getTransformedValue() ? false : true);\n\n  if (ref.current === null && getInitialHTML) {\n    ref.current = getInitialHTML(defaultValue ? defaultValue : '');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // @ts-ignore\n    divAttributes['data-cy'] = 'input';\n  }\n\n  const mergeOnKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key === 'Enter') {\n      if (onEnter && !opened) {\n        //Because the updates, has to be applied for the event to get the correct value\n        //TODO: Better handling\n        setTimeout(() => {\n          onEnter();\n        }, 200);\n      }\n\n      if (singleLine) {\n        event.preventDefault();\n      }\n    }\n    onKeyDown(event);\n\n    if (divAttributes.onKeyDown) {\n      divAttributes.onKeyDown(event);\n    }\n  };\n\n  const onInput = (event: React.FormEvent<HTMLDivElement>) => {\n    if (divAttributes.onInput) {\n      divAttributes.onInput(event);\n    }\n    onChanges(event);\n    setEmpty(getTransformedValue() ? false : true);\n  };\n\n  const onBeforeInput = (event: React.FormEvent<HTMLDivElement>) => {\n    onBeforeChanges(event);\n\n    if (divAttributes.onBeforeInput) {\n      divAttributes.onBeforeInput(event);\n    }\n  };\n\n  let style = {};\n  if (singleLine) {\n    style = { whiteSpace: 'nowrap', overflow: 'hidden' };\n  }\n\n  return (\n    <div\n      ref={setInputElement}\n      {...divAttributes}\n      className={`${styles.xinput} ${\n        isEmpty ? styles.xempty : ''\n      } ${className}`}\n      contentEditable={true}\n      onBeforeInput={onBeforeInput}\n      onKeyDown={mergeOnKeyDown}\n      onInput={onInput}\n      data-ph={placeholder}\n      dangerouslySetInnerHTML={{ __html: ref.current || '' }}\n      style={style}\n    ></div>\n  );\n}\n","import React, {\n  FormEvent,\n  KeyboardEvent,\n  useEffect,\n  useState,\n  useRef,\n} from 'react';\n\nimport {\n  initialContext,\n  RichMentionsContext,\n  TMentionItem,\n  TMentionContext,\n  TMentionConfig,\n} from './RichMentionsContext';\n\nimport { getFragment } from './utils/getFragment';\nimport { fixCursorInsertion } from './utils/fixCursorInsertion';\nimport { insertFragment as insertFragmentUtils } from './utils/insertFragment';\nimport { getTransformedValue as getTransformedValueUtils } from './utils/getTransformedValue';\nimport { handleFragmentEscape } from './utils/handleFragmentEscape';\nimport { removeBrokenFragments } from './utils/removeBrokenFragments';\nimport { handleFragmentCreation } from './utils/handleFragmentCreation';\nimport { handleFragmentDeletion } from './utils/handleFragmentDeletion';\nimport { getConfigsInitialValue } from './utils/getConfigsInitialValue';\nimport { transformFinalFragment } from './utils/transformFinalFragment';\nimport { deleteSelection } from './utils/deleteSelection';\n\ninterface TProps<T = object> {\n  children: React.ReactNode | React.ReactNode[];\n  configs: TMentionConfig<T>[];\n  onUpdate?: (value: string) => void;\n  getContext?:\n    | React.MutableRefObject<TMentionContext | null>\n    | ((ref: TMentionContext) => void);\n  getInitialHTML?: (text: string) => string;\n}\n\nexport function RichMentionsProvider<T = object>({\n  children,\n  configs,\n  getContext,\n  onUpdate,\n  getInitialHTML = getConfigsInitialValue(configs),\n}: TProps<T>) {\n  // The reference to always have function context working\n  const ref = useRef<TMentionContext>({\n    ...initialContext,\n    getInitialHTML,\n    setPositionFixed,\n    setInputElement,\n    selectItem,\n    onBeforeChanges,\n    onChanges,\n    onKeyDown,\n    closeAutocomplete,\n    openAutocomplete,\n    setActiveItemIndex,\n    getTransformedValue,\n    insertFragment,\n    setValue,\n  });\n\n  // The state to controls react rendering\n  const [__ctx__, setState] = useState<TMentionContext>(ref.current);\n  const updateState = (data: Partial<TMentionContext>) => {\n    ref.current = {\n      ...ref.current,\n      ...data,\n    };\n    setState(ref.current);\n  };\n\n  // Listen for selection change to open/close the autocomplete modal\n  useEffect(() => {\n    document.addEventListener('selectionchange', onSelectionChange, false);\n    return () => {\n      document.removeEventListener('selectionchange', onSelectionChange, false);\n    };\n  });\n\n  // Expose reference with new context\n  useEffect(() => {\n    if (typeof getContext === 'function') {\n      getContext(__ctx__);\n    } else if (typeof getContext === 'object') {\n      getContext.current = __ctx__;\n    }\n  }, [getContext, __ctx__]);\n\n  /**\n   * Listener to update autocomplete css fixed position\n   * Helpful if you have an input fixed at the top/bottom of your website.\n   *\n   * @param {boolean} fixed Is input element position fixed ? Help to set correct autocomplete position\n   * @returns {void}\n   */\n  function setPositionFixed(fixed: boolean): void {\n    updateState({ fixed });\n  }\n\n  /**\n   * Listener to set new inputElement.\n   * Should be used only by the <InputElement /> to mount/unmount itself\n   *\n   * @param {HTMLDivElement | null} inputElement input element\n   * @returns {void}\n   */\n  function setInputElement(inputElement: HTMLDivElement | null): void {\n    updateState({ inputElement });\n  }\n\n  /**\n   * Called by the autocomplete to select an item.\n   * It will transform the current pending fragment to a final one and\n   * reset the autocomplete\n   *\n   * @param {TMentionItem} item The item from autocomplete to select\n   * @returns {void}\n   */\n  function selectItem(item: TMentionItem<T>): void {\n    const opened = ref.current.opened;\n\n    if (opened?.element) {\n      transformFinalFragment(opened.element, item.ref, opened.config);\n    }\n\n    updateState({\n      index: 0,\n      results: [],\n      opened: null,\n      loading: false,\n      activeSearch: '',\n    });\n  }\n\n  /**\n   * Bounded to input.onBeforeInput event.\n   * Will help to insert/delete/escape fragment before it already happens to avoid a flash\n   *\n   * @param {FormEvent<HTMLDivElement>} event\n   * @returns {void}\n   */\n  function onBeforeChanges(event: FormEvent<HTMLDivElement>): void {\n    let selection = document.getSelection();\n    if (!selection || !selection.anchorNode) {\n      return;\n    }\n\n    // If there is text selection, delete it.\n    // We need to do it manually because of the preventDefault() :'(\n    // Update 'text' variable as the content could be updated\n    if (deleteSelection(selection, event)) {\n      selection = document.getSelection();\n      if (!selection || !selection.anchorNode) {\n        return;\n      }\n    }\n\n    fixCursorInsertion(event, selection);\n    handleFragmentDeletion(event, selection);\n    handleFragmentEscape(event, selection, configs);\n    handleFragmentCreation(event, selection, configs, ref.current);\n    removeBrokenFragments<T>(event.currentTarget, configs);\n  }\n\n  /**\n   * Will handle document.onSelectionChange event\n   * In this case, just to know if wha have focus on a fragment to open/close the autocomplete\n   *\n   * @returns {void}\n   */\n  function onSelectionChange(): void {\n    const {\n      inputElement,\n      opened,\n      closeAutocomplete,\n      openAutocomplete,\n      getTransformedValue,\n    } = ref.current;\n\n    const selection = document.getSelection();\n    const fragment =\n      selection?.anchorNode &&\n      (getFragment(selection.anchorNode) ||\n        (selection.anchorOffset === 0 &&\n          selection.anchorNode.previousSibling &&\n          getFragment(selection.anchorNode.previousSibling)));\n\n    const shouldOpened =\n      fragment &&\n      !fragment.hasAttribute('data-integrity') &&\n      inputElement &&\n      inputElement.contains(fragment);\n\n    if (opened && !shouldOpened) {\n      closeAutocomplete();\n    } else if (\n      shouldOpened &&\n      fragment &&\n      (!opened || opened.element !== fragment)\n    ) {\n      const text = fragment.textContent || '';\n      const config = configs.find(cfg => text.match(cfg.query));\n      if (config) {\n        openAutocomplete(fragment, text, config);\n      }\n    }\n    onUpdate && onUpdate(getTransformedValue());\n  }\n\n  /**\n   * Handle input.onChange event\n   * This part is just to remove broken fragment (let say you removed the \"@\" of a mention) and to\n   * Open/Close autocomplete based on the new cursor position.\n   *\n   * @param {FormEvent<HTMLDivElement>} event\n   * @returns {void}\n   */\n  function onChanges(): void {\n    const { inputElement, openAutocomplete, closeAutocomplete } = ref.current;\n    const selection = document.getSelection();\n\n    if (inputElement) {\n      removeBrokenFragments<T>(inputElement, configs);\n    }\n\n    // Autocomplete\n    const fragment = selection?.anchorNode && getFragment(selection.anchorNode);\n\n    if (fragment && !fragment.hasAttribute('data-integrity')) {\n      const text = fragment.textContent || '';\n      const config = configs.find(cfg => text.match(cfg.query));\n      if (config) {\n        openAutocomplete(fragment, text, config);\n      }\n    } else if (ref.current.opened) {\n      closeAutocomplete();\n    }\n\n    onUpdate && onUpdate(getTransformedValue());\n  }\n\n  /**\n   * Handle input.onKeyDown event\n   * Just to manage the selected item on the autocomplete if opened\n   *\n   * @param {KeyboardEvent<HTMLDivElement>} event\n   * @returns {void}\n   */\n  function onKeyDown(event: KeyboardEvent<HTMLDivElement>): void {\n    const {\n      opened,\n      results,\n      index,\n      selectItem,\n      closeAutocomplete,\n    } = ref.current;\n\n    if (!opened || !results.length) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case 40: // down\n        event.preventDefault();\n        updateState({\n          index: Math.min(index + 1, results.length - 1),\n        });\n        break;\n\n      case 38: // up\n        event.preventDefault();\n        updateState({\n          index: Math.max(index - 1, 0),\n        });\n        break;\n\n      case 9: // tab\n      case 13: // enter\n        if (results[index]) {\n          event.preventDefault();\n          selectItem(results[index]);\n        }\n        break;\n\n      case 27: // escape\n        closeAutocomplete();\n        break;\n    }\n  }\n\n  /**\n   * Public method to close the autocomplete\n   *\n   * @returns {void}\n   */\n  function closeAutocomplete(): void {\n    updateState({\n      opened: null,\n      loading: false,\n      results: [],\n      index: 0,\n      activeSearch: '',\n    });\n  }\n\n  /*\n  function getCaretCoordinates() {\n    let x = 0,\n      y = 0;\n    const isSupported = typeof window.getSelection !== \"undefined\";\n    if (isSupported) {\n      const selection = window.getSelection();\n      if (selection && selection.rangeCount !== 0) {\n        const range = selection.getRangeAt(0).cloneRange();\n        range.collapse(true);\n        const rect = range.getClientRects()[0];\n        if (rect) {\n          x = rect.left;\n          y = rect.top;\n        }\n      }\n    }\n    return { x, y };\n  }\n\n  */\n\n  /**\n   * Public method to open the autocomplete\n   *\n   * @param {HTMLElement} node Selected fragment where to open the autocomplete (for position)\n   * @param {string} text The fragment text we are autocompleting for\n   * @param {TMentionConfig} config The config object linked to the mention\n   * @returns {void}\n   */\n  function openAutocomplete<T>(\n    node: HTMLElement,\n    text: string,\n    config: TMentionConfig<T>\n  ): void {\n    //const fixed = ref.current.fixed;\n    //const rect = { top: 0, right: 0, bottom: 0, left: 0 };\n    let nodeRect = node.getBoundingClientRect();\n    let parentRect = { top: 0, right: 0, bottom: 0, left: 0 }; //node.getBoundingClientRect();\n    //const rects = node.getClientRects();\n\n    if (ref.current.inputElement) {\n      parentRect = ref.current.inputElement.getBoundingClientRect();\n    }\n\n    //const caretPos = getCaretCoordinates();\n    const x = nodeRect.right - parentRect.left;\n    const y = nodeRect.bottom - parentRect.top;\n    /*rect.top = nodeRect.top;\n    rect.right = nodeRect.right;\n    rect.bottom = nodeRect.bottom;\n    rect.left = nodeRect.left;\n\n    // Substract based on relative parent if not position:fixed\n    if (!fixed && node.offsetParent) {\n      const parentRect = node.offsetParent.getBoundingClientRect();\n      rect.top -= parentRect.top;\n      rect.right = rect.right - parentRect.right + parentRect.width;\n      rect.left -= parentRect.left;\n      rect.bottom = rect.bottom - parentRect.bottom + parentRect.height;\n    }\n\n    // TODO ELEMENT_WIDTH and ELEMENT_HEIGHT from Input Autocomplete element\n    const ELEMENT_WIDTH = 200;\n    const ELEMENT_HEIGHT = 300;\n\n    // TODO calculate overflow\n    const overflowX = nodeRect.left + 10 + ELEMENT_WIDTH - window.innerWidth;\n    const overflowY = nodeRect.bottom + ELEMENT_HEIGHT - window.innerHeight;\n\n    const x = 200; //overflowX > 0 ? rect.right + 15 : rect.left - 3;\n    const y = 10;//overflowY > 0 ? rect.top - 3 : rect.bottom + 3;\n    */\n\n    updateState({\n      loading: true,\n      index: 0,\n      opened: {\n        config,\n        fixed: true,\n        bottom: true,\n        right: true,\n        element: node,\n        x,\n        y,\n      },\n      activeSearch: text,\n    });\n\n    const onResolve = (results: TMentionItem[] = []) => {\n      if (ref.current.opened?.element === node) {\n        updateState({\n          results,\n          loading: false,\n        });\n      }\n    };\n\n    const p = config.onMention(text, onResolve);\n    if (p instanceof Promise) {\n      p.then(onResolve, onResolve);\n    } else if (p instanceof Array) {\n      onResolve(p);\n    }\n  }\n\n  /**\n   * Just set the active item in the autocomplete based on the index.\n   * Will work only if autocomplete is already opened\n   *\n   * @param {number} index The active element in autocomplete to hover\n   * @returns {void}\n   */\n  function setActiveItemIndex(index: number): void {\n    updateState({ index });\n  }\n\n  /**\n   * Transform input html content to usable text by transforming the\n   * fragments to valid text and erasing all invalid fragments.\n   *\n   * @returns {string}\n   */\n  function getTransformedValue(): string {\n    return getTransformedValueUtils(ref.current.inputElement);\n  }\n\n  /**\n   * Helper to be able to insert a fragment \"<@test|U211212>\" inside the text\n   *\n   * @param {string} code The code to insert as fragment (preprocess by configs). Ex: \"<@test|U211212>\"\n   * @param {HTMLElement?} element (optional) the html element to insert\n   * @returns {void}\n   */\n  function insertFragment(\n    code: string,\n    element: HTMLElement | null = null\n  ): void {\n    insertFragmentUtils<T>(code, element, configs, ref.current.inputElement);\n  }\n\n  /**\n   * Helper to be able to change the input content externaly\n   *\n   * @param {string} text The text to insert\n   * @returns {void}\n   */\n  function setValue(text: string): void {\n    const { inputElement, closeAutocomplete } = ref.current;\n\n    if (inputElement) {\n      inputElement.innerHTML = getInitialHTML(text);\n      removeBrokenFragments(inputElement, configs);\n    }\n\n    closeAutocomplete();\n  }\n\n  return (\n    <RichMentionsContext.Provider value={__ctx__}>\n      {children}\n    </RichMentionsContext.Provider>\n  );\n}\n","import { TMentionConfig } from './../RichMentionsContext';\nimport { transformFinalFragment } from './transformFinalFragment';\n\nfunction replaceSpacesWithInsecableSpaces(text: string): string {\n  const div = document.createElement('div');\n  div.innerHTML = text;\n\n  function recursiveSpaceReplacer(element: HTMLElement) {\n    Array.from(element.childNodes).forEach(element => {\n      if (element instanceof Text && element.nodeValue) {\n        element.nodeValue = element.nodeValue.replace(/( |\\t)/g, '\\u00A0');\n      } else if (element instanceof HTMLElement) {\n        recursiveSpaceReplacer(element);\n\n        if (\n          element.hasAttribute('data-rich-mentions') &&\n          !element.hasAttribute('data-integrity')\n        ) {\n          element.setAttribute('data-integrity', element.innerHTML);\n        }\n      }\n    });\n  }\n\n  recursiveSpaceReplacer(div);\n\n  return div.innerHTML;\n}\n\nexport function getConfigsInitialValue(configs: TMentionConfig<any>[]) {\n  return (text: string): string => {\n    // This replace all fragment \"<@vince|U515>\" to html ones based on your configs\n    const formattedTextWithHtml = configs.reduce((acc, config) => {\n      return acc.replace(config.match, $0 => {\n        const span = document.createElement('span');\n        transformFinalFragment(span, $0, config);\n        return span.outerHTML;\n      });\n    }, text);\n\n    // We replace all text spaces with unbreakable ones to avoid problem with contenteditable.\n    // Currently, contenteditable remove multiple space but we want to keep it.\n    return replaceSpacesWithInsecableSpaces(formattedTextWithHtml);\n  };\n}\n","import { nodeToHtmlElement } from './nodeToHtmlElement';\nimport { escapeFragmentWithValue } from './escapeFragmentWithValue';\n\nexport function fixCursorInsertion(\n  event: React.FormEvent<HTMLDivElement>,\n  selection: Selection\n): void {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // @ts-ignore\n  const insertion: string = event.data;\n  const container = event.currentTarget;\n\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n\n    // Same element\n    if (range.startContainer === range.endContainer) {\n      const element = nodeToHtmlElement(range.startContainer);\n\n      if (!container.contains(element)) {\n        continue;\n      }\n\n      // If outside pending fragment, insert char inside\n      if (range.startContainer instanceof Text && range.startOffset === 0) {\n        const previousChild = range.startContainer.previousSibling;\n        const previousElement = range.startContainer.previousElementSibling;\n        if (\n          previousChild &&\n          previousElement &&\n          previousChild === previousElement &&\n          previousElement.hasAttribute('data-rich-mentions') &&\n          !previousElement.hasAttribute('data-integrity')\n        ) {\n          previousElement.appendChild(document.createTextNode(insertion));\n          event.preventDefault();\n          continue;\n        }\n      }\n\n      // TODO range.endContainer\n      if (\n        !element ||\n        container === element ||\n        !element.hasAttribute('data-rich-mentions')\n      ) {\n        continue;\n      }\n\n      // At first position of fragment, move before it\n      if (range.endOffset === 0) {\n        escapeFragmentWithValue(element, insertion, 'before');\n        event.preventDefault();\n        continue;\n      }\n\n      const isFinal = element.hasAttribute('data-integrity');\n      const text = element.textContent || '';\n\n      // Move outside final fragment\n      if (isFinal && range.startOffset === text.length) {\n        escapeFragmentWithValue(element, insertion, 'after');\n        event.preventDefault();\n        continue;\n      }\n    }\n  }\n}\n","import { TMentionConfig } from '../RichMentionsContext';\nimport { getFragment } from './getFragment';\nimport { escapeFragmentWithValue } from './escapeFragmentWithValue';\n\nexport function handleFragmentEscape(\n  event: React.FormEvent<HTMLDivElement>,\n  { anchorNode }: Selection,\n  configs: TMentionConfig<any>[]\n) {\n  if (event.defaultPrevented || !anchorNode) {\n    return;\n  }\n\n  const element = getFragment(anchorNode);\n\n  if (element) {\n    // @ts-ignore\n    const insertion: string = event.data;\n    const newText = element.textContent + insertion;\n    const isValid = configs.some(cfg => {\n      const matches = newText.match(cfg.query);\n      return matches && matches[0] === matches.input;\n    });\n\n    if (!isValid) {\n      event.preventDefault();\n      escapeFragmentWithValue(element, insertion);\n    }\n  }\n}\n","import { TMentionConfig, TMentionContext } from '../RichMentionsContext';\nimport { setCursorPosition } from './setCursorPosition';\nimport { getFragment } from './getFragment';\n\nexport function handleFragmentCreation(\n  event: React.FormEvent<HTMLDivElement>,\n  selection: Selection,\n  configs: TMentionConfig<any>[],\n  ctx: TMentionContext\n): void {\n  const { anchorNode, anchorOffset } = selection;\n\n  if (event.defaultPrevented || !anchorNode || getFragment(anchorNode)) {\n    return;\n  }\n\n  // @ts-ignore Find a property type instead of React.FormEvent<HTMLDivElement> ?\n  const insertion: string = event.data;\n  const fragmentText = anchorNode.textContent || '';\n\n  // Build new text fragment with insertion\n  const text =\n    fragmentText.substr(0, anchorOffset) +\n    insertion +\n    fragmentText.substr(anchorOffset);\n\n  // No match\n  const config = configs.find(cfg => text.match(cfg.query));\n  if (!config) {\n    return;\n  }\n\n  const matches = text.match(config.query) as RegExpMatchArray;\n  const index = matches.index || 0;\n  const textBeforeQuery = text.substr(0, index);\n\n  // Do nothing if there is a valid character before.\n  // Do nothing if the range overflow the fragment position\n  if (\n    (textBeforeQuery.length && !/\\W$/.test(textBeforeQuery)) ||\n    anchorOffset < index ||\n    anchorOffset >= index + matches[0].length\n  ) {\n    return;\n  }\n\n  anchorNode.textContent = textBeforeQuery;\n\n  const fragment = document.createElement('span');\n  const textQuery = matches[0].substr(\n    0,\n    anchorOffset - index + insertion.length\n  );\n  const afterInsertion = text.substr(index + textQuery.length);\n\n  fragment.setAttribute('data-rich-mentions', '');\n  fragment.setAttribute('spellcheck', 'false');\n\n  if (process.env.NODE_ENV !== 'production') {\n    fragment.setAttribute('data-cy', 'pending');\n  }\n\n  fragment.textContent = textQuery;\n\n  if (config.customizeFragment) {\n    config.customizeFragment(fragment, false);\n  }\n\n  const after = document.createTextNode(\n    /^\\s/.test(afterInsertion) ? afterInsertion : ' ' + afterInsertion\n  );\n\n  const isContainer = event.currentTarget === anchorNode;\n  const parent = isContainer ? anchorNode : anchorNode.parentElement;\n\n  if (parent) {\n    if (isContainer) {\n      parent.appendChild(fragment);\n      parent.appendChild(after);\n    } else {\n      parent.insertBefore(after, anchorNode.nextSibling);\n      parent.insertBefore(fragment, anchorNode.nextSibling);\n    }\n  }\n\n  event.preventDefault();\n  setCursorPosition(\n    fragment.childNodes[0],\n    anchorOffset - textBeforeQuery.length + 1\n  );\n\n  ctx.openAutocomplete(fragment, textQuery, config);\n}\n","import { TMentionContext } from '../RichMentionsContext';\n\nexport function getTransformedValue(\n  inputElement: TMentionContext['inputElement']\n): string {\n  if (!inputElement || inputElement.innerHTML === '<br>') {\n    return '';\n  }\n\n  const brCharacter = `_br_${Date.now()}_`;\n  const brMatcher = new RegExp(`\\\\n?${brCharacter}\\\\n?`, 'g');\n\n  return Array.from(inputElement.childNodes)\n    .map(el => getNodeContent(el, brCharacter))\n    .join('')\n    .replace(/\\u00A0/g, ' ') // Replace back insecable spaces\n    .replace(/\\n{2,}/g, '\\n') // Following lines are considered as one in HTML\n    .replace(brMatcher, '\\n') // Replace <br/> to line break\n    .trim();\n}\n\nfunction getNodeContent(element: Node, brCharacter: string): string {\n  if (element instanceof Text) {\n    return element.textContent || '';\n  }\n\n  if (element instanceof HTMLBRElement) {\n    return brCharacter;\n  }\n\n  if (element instanceof Element) {\n    const richValue = element.getAttribute('data-rich-mentions');\n    if (richValue) {\n      return richValue;\n    }\n\n    const char = element instanceof HTMLDivElement ? '\\n' : '';\n    const result = Array.from(element.childNodes)\n      .map(el => getNodeContent(el, brCharacter))\n      .join('');\n\n    return `${char}${result}${char}`;\n  }\n\n  return '';\n}\n"],"names":["noop","initialContext","getTransformedValue","insertFragment","setValue","activeSearch","inputElement","setInputElement","selectItem","setActiveItemIndex","opened","index","loading","results","closeAutocomplete","openAutocomplete","onBeforeChanges","onKeyDown","onChanges","fixed","setPositionFixed","RichMentionsContext","createContext","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","nodeToHtmlElement","node","nodeType","Node","TEXT_NODE","parentElement","getFragment","element","hasAttribute","setCursorPosition","position","selection","getSelection","range","createRange","setStart","collapse","removeAllRanges","addRange","escapeFragmentWithValue","text","textNode","replace","parent","nextSibling","length","deleteSelection","event","deleted","lastDeletedRange","i","rangeCount","getRangeAt","startContainer","endContainer","startOffset","endOffset","deleteContents","data","insertNode","preventDefault","transformFinalFragment","span","config","content","match","matchDisplay","textContent","setAttribute","customizeFragment","innerHTML","removeBrokenFragments","configs","Array","from","children","forEach","fixBrokenElement","HTMLBRElement","div","HTMLDivElement","attributes","Text","removeChild","getAttribute","some","cfg","query","isSpace","char","test","needSpaceBefore","offset","defaultValue","charAt","includes","nodeName","previousSibling","prevText","needSpaceAfter","nextText","removeIfFinalFragment","container","contains","className","itemClassName","selectedItemClassName","useContext","onSelectItem","item","onHoverItem","itemAttributes","useEffect","React","left","x","top","y","bottom","right","map","key","onClick","onMouseOver","name","singleLine","placeholder","onEnter","divAttributes","useRef","getInitialHTML","useState","isEmpty","setEmpty","current","whiteSpace","overflow","styles","contentEditable","onBeforeInput","setTimeout","onInput","dangerouslySetInnerHTML","__html","getContext","onUpdate","recursiveSpaceReplacer","childNodes","nodeValue","HTMLElement","replaceSpacesWithInsecableSpaces","reduce","acc","$0","outerHTML","getConfigsInitialValue","updateState","anchorNode","defaultPrevented","insertion","currentTarget","previousChild","previousElement","previousElementSibling","fixCursorInsertion","handleFragmentDeletion","newText","matches","input","handleFragmentEscape","ctx","anchorOffset","fragmentText","substr","find","textBeforeQuery","fragment","textQuery","afterInsertion","after","isContainer","handleFragmentCreation","keyCode","Math","min","max","nodeRect","getBoundingClientRect","parentRect","onResolve","p","onMention","Promise","then","code","customFragment","insertAfterNode","insertBeforeNode","addSpaceBefore","addSpaceAfter","firstPart","secondPart","subFragment","firstElementChild","space","insertFragmentUtils","__ctx__","setState","onSelectionChange","shouldOpened","brCharacter","Date","now","brMatcher","RegExp","el","getNodeContent","Element","richValue","join","trim","getTransformedValueUtils","addEventListener","removeEventListener","Provider","value"],"mappings":"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"}