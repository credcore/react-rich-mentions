{"version":3,"file":"react-rich-mentions.cjs.production.min.js","sources":["../src/utils/noop.ts","../src/RichMentionsContext.ts","../src/utils/nodeToHtmlElement.ts","../src/utils/getFragment.ts","../src/utils/setCursorPosition.ts","../src/utils/escapeFragmentWithValue.ts","../src/utils/deleteSelection.ts","../src/utils/transformFinalFragment.ts","../src/utils/removeBrokenFragments.ts","../src/utils/insertFragment.ts","../src/utils/handleFragmentDeletion.ts","../src/RichMentionsAutocomplete.tsx","../src/RichMentionsInput.tsx","../src/RichMentionsProvider.tsx","../src/utils/getConfigsInitialValue.ts","../src/utils/fixCursorInsertion.ts","../src/utils/handleFragmentEscape.ts","../src/utils/handleFragmentCreation.ts","../src/utils/getTransformedValue.ts"],"sourcesContent":["export const noop = () => {};\n","import { createContext } from 'react';\nimport { noop } from './utils/noop';\n\nexport type TMentionItem<T = object> = T & {\n  name: string;\n  ref: string;\n};\n\nexport interface TMentionConfig<T = object> {\n  query: RegExp;\n  match: RegExp;\n  matchDisplay: string;\n  customizeFragment?: (fragment: HTMLSpanElement, final: boolean) => void;\n  onMention: (\n    text: string,\n    callback?: (results: TMentionItem<T>[]) => void\n  ) => void | TMentionItem<T>[] | Promise<TMentionItem<T>[]>;\n}\n\nexport interface TMentionContext {\n  getTransformedValue: () => string;\n  setValue: (text: string) => void;\n  insertFragment: (ref: string, element?: HTMLElement) => void;\n  activeSearch: string;\n  inputElement: HTMLDivElement | null;\n  setInputElement: (newInputElement: HTMLDivElement | null) => void;\n  selectItem: (item: TMentionItem<any>) => void;\n  setActiveItemIndex: (index: number) => void;\n  opened: null | {\n    config: TMentionConfig<any>;\n    element: HTMLSpanElement;\n    fixed: boolean;\n    bottom: boolean;\n    right: boolean;\n    x: number;\n    y: number;\n  };\n  index: number;\n  loading: boolean;\n  results: TMentionItem<any>[];\n  closeAutocomplete: () => void;\n  openAutocomplete: <T>(\n    node: HTMLElement,\n    value: string,\n    config: TMentionConfig<T>\n  ) => void;\n  onBeforeChanges: (event: React.FormEvent<HTMLDivElement>) => void;\n  onKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n  onChanges: (event: React.FormEvent<HTMLDivElement>) => void;\n  getInitialHTML?: (value: string) => string;\n  fixed: boolean;\n  setPositionFixed: (fixed: boolean) => void;\n}\n\nexport const initialContext: TMentionContext = {\n  getTransformedValue: () => '',\n  insertFragment: noop,\n  setValue: noop,\n  activeSearch: '',\n  inputElement: null,\n  setInputElement: noop,\n  selectItem: noop,\n  setActiveItemIndex: noop,\n  opened: null,\n  index: 0,\n  loading: false,\n  results: [],\n  closeAutocomplete: noop,\n  openAutocomplete: noop,\n  onBeforeChanges: noop,\n  onKeyDown: noop,\n  onChanges: noop,\n  fixed: true,\n  setPositionFixed: noop,\n};\n\nexport const RichMentionsContext = createContext<TMentionContext>(\n  initialContext\n);\n","export function nodeToHtmlElement(node: Node): HTMLElement | null {\n  return node.nodeType === Node.TEXT_NODE\n    ? node.parentElement\n    : (node as HTMLElement);\n}\n","import { nodeToHtmlElement } from './nodeToHtmlElement';\n\nexport function getFragment(node: Node): HTMLElement | null {\n  const element = nodeToHtmlElement(node);\n  return element && element.hasAttribute('data-rich-mentions') ? element : null;\n}\n","export function setCursorPosition(\n  element: HTMLElement | Node | Text,\n  position: number\n): void {\n  const selection = document.getSelection();\n  const range = document.createRange();\n\n  range.setStart(element, position);\n  range.collapse(true);\n\n  if (selection) {\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}\n","import { setCursorPosition } from './setCursorPosition';\n\nexport function escapeFragmentWithValue(\n  element: HTMLElement,\n  text: string,\n  position: 'after' | 'before' = 'after'\n) {\n  const textNode = document.createTextNode(text.replace(/\\s/g, '\\u00A0'));\n  const parent = element.parentElement;\n\n  if (parent) {\n    if (position === 'after') {\n      parent.insertBefore(textNode, element.nextSibling);\n    } else {\n      parent.insertBefore(textNode, element);\n    }\n    setCursorPosition(textNode, text.length);\n  }\n}\n","import { setCursorPosition } from './setCursorPosition';\n\nexport function deleteSelection(\n  selection: Selection,\n  event?: React.FormEvent<HTMLDivElement>\n): boolean {\n  let deleted = false;\n  let lastDeletedRange = null;\n\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    const range = selection.getRangeAt(i);\n\n    if (\n      range.startContainer !== range.endContainer ||\n      range.startOffset !== range.endOffset\n    ) {\n      deleted = true;\n      lastDeletedRange = range;\n      range.deleteContents();\n    }\n  }\n\n  // @ts-ignore\n  if (event?.data && lastDeletedRange) {\n    // @ts-ignore\n    const textNode = document.createTextNode(event.data);\n    lastDeletedRange.insertNode(textNode);\n    setCursorPosition(textNode, 1);\n    event.preventDefault();\n  }\n\n  return deleted;\n}\n","import { TMentionConfig, TMentionItem } from '../RichMentionsContext';\nimport { setCursorPosition } from './setCursorPosition';\n\nexport function transformFinalFragment<T>(\n  span: HTMLSpanElement,\n  ref: TMentionItem['ref'],\n  config: TMentionConfig<T>\n): void {\n  const content = ref\n    .replace(config.match, config.matchDisplay)\n    .replace(/\\s/g, '\\u00A0');\n\n  span.textContent = content;\n  span.setAttribute('data-rich-mentions', ref);\n  span.setAttribute('spellcheck', 'false');\n\n  if (process.env.NODE_ENV !== 'production') {\n    span.setAttribute('data-cy', 'final');\n  }\n\n  if (config.customizeFragment) {\n    config.customizeFragment(span, true);\n  }\n\n  span.setAttribute('data-integrity', span.innerHTML);\n\n  if (span.parentElement) {\n    // TODO only if no space after\n    const textNode = document.createTextNode('\\u00A0');\n    span.parentElement.insertBefore(textNode, span.nextSibling);\n    setCursorPosition(textNode, 1);\n  }\n}\n","import { TMentionConfig } from '../RichMentionsContext';\n\nexport function removeBrokenFragments<T>(\n  inputElement: HTMLDivElement,\n  configs: TMentionConfig<T>[]\n) {\n  Array.from(inputElement.children).forEach(function fixBrokenElement(\n    element,\n    index\n  ) {\n    const parent = element.parentElement as HTMLElement;\n\n    // Replace BR with div>br\n    // There is a bug on chrome occuring when the cursor is just after a br, the selection is broken and\n    // we can't locate its position. By moving them inside a div it fixes the problem\n    if (element instanceof HTMLBRElement) {\n      if (\n        parent.children.length !== 1 &&\n        index !== parent.children.length - 1\n      ) {\n        const div = document.createElement('div');\n        parent.insertBefore(div, element);\n        div.appendChild(element);\n      }\n      return;\n    }\n\n    if (element instanceof HTMLDivElement && !element.attributes.length) {\n      Array.from(element.children).forEach(fixBrokenElement);\n      return;\n    }\n\n    const text = element.textContent || '';\n\n    // Fixes a Chrome bug:\n    // - Add a span with color on a contenteditable.\n    // - Remove the span with backspace.\n    // - Type text.\n    // Chrome will try to restore the style by adding a <font> with specific styles.\n    if (\n      !(element instanceof Text) &&\n      !element.hasAttribute('data-rich-mentions')\n    ) {\n      parent.insertBefore(document.createTextNode(text), element);\n      parent.removeChild(element);\n      return;\n    }\n\n    // On final fragments, avoid edition.\n    // The data-integrity attribute contains the original fragment content.\n    // If it does not match, just remove the entire fragment.\n    if (element.hasAttribute('data-integrity')) {\n      // final fragment, if not valid remove it completely\n      if (element.getAttribute('data-integrity') !== element.innerHTML) {\n        parent.removeChild(element);\n      }\n      return;\n    }\n\n    // If we have a pending fragment that is now invalid since the last (let\n    // say you just removed the '@' from it, then we can safely extract the\n    // text, remove the fragment, and insert the text back without it.\n    const isValid = configs.some(cfg => text.match(cfg.query));\n    if (!isValid) {\n      parent.insertBefore(document.createTextNode(text), element.nextSibling);\n      parent.removeChild(element);\n    }\n  });\n}\n","import { getFragment } from './getFragment';\nimport { deleteSelection } from './deleteSelection';\nimport { setCursorPosition } from './setCursorPosition';\nimport { transformFinalFragment } from './transformFinalFragment';\nimport { TMentionConfig } from '../RichMentionsContext';\nimport { removeBrokenFragments } from './removeBrokenFragments';\n\nconst isSpace = (char: string) => /(\\u00A0|\\s)/.test(char);\n\nconst needSpaceBefore = (\n  text: string,\n  offset: number,\n  node: Node,\n  defaultValue: boolean\n): boolean => {\n  if (offset > 0) {\n    return !isSpace(text.charAt(offset - 1));\n  }\n\n  // Do not add space if the previous element is a block adding a line break\n  if (['DIV', 'BR'].includes(node.nodeName)) {\n    return false;\n  }\n\n  if (node.previousSibling) {\n    // TODO get first previous element with text\n    const prevText = node.previousSibling.textContent || '';\n    return !!prevText.length && !isSpace(prevText.charAt(prevText.length - 1));\n  }\n\n  return defaultValue;\n};\n\nconst needSpaceAfter = (text: string, offset: number, node: Node): boolean => {\n  if (offset < text.length) {\n    return !isSpace(text.charAt(text.length - 1));\n  }\n\n  if (!node.nextSibling) {\n    return true;\n  }\n\n  const nextText = node.nextSibling.textContent || '';\n  // TODO get first next fragment with content...\n  return !nextText.length || !isSpace(nextText.charAt(0));\n};\n\nexport function insertFragment<T>(\n  ref: string,\n  customFragment: HTMLElement | null,\n  configs: TMentionConfig<T>[],\n  inputElement: HTMLDivElement | null\n) {\n  const config = configs.find(cfg => ref.match(cfg.match));\n\n  // inputElement was removed from DOM for some reasons\n  if (!inputElement || (!config && !customFragment)) {\n    return;\n  }\n\n  let insertAfterNode: Node | null = null;\n  let insertBeforeNode: Node | null = null;\n  let addSpaceBefore = false;\n  let addSpaceAfter = false;\n\n  const selection = document.getSelection();\n\n  // Is selection inside inputElement ?\n  // (avoid inserting fragments on other parts of the website)\n  if (\n    selection &&\n    selection.anchorNode &&\n    inputElement.contains(selection.anchorNode)\n  ) {\n    let { anchorNode: node, anchorOffset: offset } = selection;\n    let fragment = getFragment(node);\n\n    // Avoid problem with text selection\n    // Just delete it before processing\n    deleteSelection(selection);\n\n    // If we are at the fragment end when inserting content, we have to\n    // change the cursor position to be at first position on the next one.\n    // If the next fragment does not exist, add a new one.\n    // <span>\"text\"|<span>   -> <span>\"text\"</span>\"|\"\n    if (fragment && offset === (node.textContent || '').length) {\n      if (!fragment.nextSibling) {\n        inputElement.insertBefore(document.createTextNode(''), null);\n      }\n      node = fragment.nextSibling as Node;\n      offset = 0;\n      fragment = null;\n    }\n\n    if (fragment) {\n      // Final fragment can't be edited\n      // Just remove it and add the insertion just after.\n      if (fragment.hasAttribute('data-integrity')) {\n        insertBeforeNode = fragment.nextSibling;\n        fragment.parentElement?.removeChild(fragment);\n      } else {\n        const text = node.textContent || '';\n\n        // In this case, we are in the middle of a pending fragment.\n        // <span>@vin|ce</span> -> <span>@vin</span>\" [insertion] \"ce\"\n        if (offset > 0 && offset < text.length) {\n          const firstPart = text.substr(0, offset);\n          const secondPart = text.substr(offset);\n          const subFragment = document.createTextNode(secondPart);\n\n          inputElement.insertBefore(subFragment, fragment.nextSibling);\n          node.textContent = firstPart;\n          addSpaceBefore = true;\n          insertBeforeNode = subFragment;\n        }\n\n        addSpaceBefore = needSpaceBefore(text, offset, node, addSpaceBefore);\n        addSpaceAfter = needSpaceAfter(text, offset, node);\n      }\n    } else {\n      // Text inside the contenteditable (not nested)\n      let text = node.textContent || '';\n\n      // If we are at the first position in a fragment, we need to insert the new\n      // fragment before it, not after.\n      if (offset > 0) {\n        insertAfterNode = node;\n      } else {\n        // If next block is <div><br/></div> we have to replace it to a single <div></div>\n        const element = node as HTMLElement;\n        if (\n          !text &&\n          element.nodeName === 'DIV' &&\n          !element.attributes.length &&\n          element.childNodes.length === 1 &&\n          element.firstElementChild instanceof HTMLBRElement\n        ) {\n          if (element.previousSibling instanceof HTMLDivElement) {\n            insertBeforeNode = node;\n            element.removeChild(element.firstElementChild);\n          } else {\n            insertAfterNode = node;\n            element.removeChild(element.firstElementChild);\n          }\n        } else {\n          insertBeforeNode = node;\n        }\n      }\n\n      // In this case, we need to add the insertion at the center of a TextNode.\n      // Let say we have \"hello|world\", as you can't add span inside TextNode, we have\n      // to split it in two differents nodes : \"Hello\" and \"world\", and insert the span\n      // between them.\n      if (offset > 0 && offset < text.length) {\n        const firstPart = text.substr(0, offset);\n        const secondPart = text.substr(offset);\n\n        text = firstPart;\n        node.textContent = firstPart;\n\n        node.parentElement?.insertBefore(\n          document.createTextNode(secondPart),\n          node.nextSibling\n        );\n      }\n\n      addSpaceBefore = needSpaceBefore(text, offset, node, addSpaceBefore);\n      addSpaceAfter = needSpaceAfter(text, offset, node);\n    }\n  } else {\n    // Can't find the selection, let's just insert the fragment at the\n    // end of the div[contenteditable]\n    const text = inputElement.textContent || '';\n    addSpaceAfter = true;\n    addSpaceBefore = !isSpace(text.charAt(text.length - 1));\n  }\n\n  // Create fragment\n  const span = document.createElement('span');\n  if (config) {\n    transformFinalFragment(span, ref, config);\n  } else if (customFragment) {\n    span.appendChild(customFragment);\n    span.setAttribute('data-rich-mentions', ref);\n    span.setAttribute('data-integrity', span.innerHTML);\n    span.setAttribute('spellcheck', 'false');\n\n    if (process.env.NODE_ENV !== 'production') {\n      span.setAttribute('data-cy', 'final');\n    }\n  }\n\n  // Insert it at chosen position\n  if (insertAfterNode && insertAfterNode !== inputElement) {\n    insertAfterNode.parentElement?.insertBefore(\n      span,\n      insertAfterNode.nextSibling\n    );\n  } else if (insertBeforeNode && insertBeforeNode !== inputElement) {\n    insertBeforeNode.parentElement?.insertBefore(span, insertBeforeNode);\n  } else {\n    inputElement.appendChild(span);\n  }\n\n  // Insert space before if needed\n  if (addSpaceBefore) {\n    const space = document.createTextNode('\\u00A0');\n    span.parentElement?.insertBefore(space, span);\n  }\n\n  // Insert space after if needed\n  if (addSpaceAfter) {\n    const space = document.createTextNode('\\u00A0');\n    span.parentElement?.insertBefore(space, span.nextSibling);\n  }\n\n  // Set cursor position (always true)\n  if (span.nextSibling) {\n    setCursorPosition(span.nextSibling, addSpaceAfter ? 1 : 0);\n  }\n\n  // If the user is selecting text and some parts of fragment, we need to be sure to delete it correctly\n  // Ex where \"[\" and \"]\" are the start and ending of text selection:\n  // input: \"he[llo <span>@vin]ce</span>\"\n  // output: \"he @insertedfragment <span>ce</span>\"\n  // In this case, the fragment \"ce\" need to be deleted.\n  removeBrokenFragments<T>(inputElement, configs);\n}\n","import { nodeToHtmlElement } from './nodeToHtmlElement';\n\nconst removeIfFinalFragment = (node: Node, container: HTMLDivElement): void => {\n  const element = nodeToHtmlElement(node);\n  if (!container.contains(element) || container === element) {\n    return;\n  }\n\n  if (element && element.hasAttribute('data-integrity')) {\n    container.removeChild(element);\n  }\n};\n\nexport function handleFragmentDeletion(\n  event: React.FormEvent<HTMLDivElement>,\n  selection: Selection\n): void {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const container = event.currentTarget;\n\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n\n    removeIfFinalFragment(range.startContainer, container);\n    removeIfFinalFragment(range.endContainer, container);\n  }\n}\n","import React, { useContext, useEffect } from 'react';\nimport { RichMentionsContext, TMentionItem } from './RichMentionsContext';\n\ninterface TProps {\n  fixed?: boolean;\n  className: string;\n  selectedItemClassName: string;\n  itemClassName: string;\n}\n\nexport function RichMentionsAutocomplete<T = object>({\n  fixed = true,\n  className,\n  itemClassName,\n  selectedItemClassName,\n}: TProps) {\n  const {\n    opened,\n    index,\n    //loading,\n    results,\n    setActiveItemIndex,\n    selectItem,\n    setPositionFixed,\n  } = useContext(RichMentionsContext);\n\n  const onSelectItem = (item: TMentionItem<T>) => () => selectItem(item);\n  const onHoverItem = (index: number) => () => setActiveItemIndex(index);\n  const divAttributes =\n    process.env.NODE_ENV !== 'production' ? { 'data-cy': 'autocomplete' } : {};\n  const itemAttributes =\n    process.env.NODE_ENV !== 'production'\n      ? { 'data-cy': 'autocomplete_item' }\n      : {};\n\n  useEffect(() => {\n    setPositionFixed(fixed);\n  }, [fixed, setPositionFixed]);\n\n  return opened && results.length ? (\n    <div\n      {...divAttributes}\n      className={`${className}`}\n      style={{\n        position: fixed ? 'fixed' : 'absolute',\n        left: opened.x + 'px',\n        top: opened.y + 'px',\n      }}\n    >\n      <div\n        className=\"autocomplete-list\"\n        style={{\n          bottom: opened.bottom ? '0px' : 'auto',\n          right: opened.right ? '0px' : 'auto',\n        }}\n      >\n        {results.map((item, i) => (\n          <button\n            className={`${itemClassName} ${\n              i === index ? selectedItemClassName : ''\n            }`}\n            type=\"button\"\n            key={item.ref}\n            onClick={onSelectItem(item)}\n            onMouseOver={onHoverItem(index)}\n            {...itemAttributes}\n          >\n            {item.name}\n          </button>\n        ))}\n      </div>\n    </div>\n  ) : null;\n}\n","import React, { HTMLProps, useRef, useContext } from 'react';\nimport { RichMentionsContext } from './RichMentionsContext';\n\ninterface TProps extends HTMLProps<HTMLDivElement> {\n  defaultValue?: string;\n  singleLine: Boolean;\n  onEnter?: () => void;\n}\n\nexport function RichMentionsInput({\n  defaultValue,\n  singleLine,\n  onEnter,\n  ...divAttributes\n}: TProps) {\n  const ref = useRef<string | null>(null);\n  const {\n    setInputElement,\n    onBeforeChanges,\n    onKeyDown,\n    onChanges,\n    getInitialHTML,\n    opened,\n  } = useContext(RichMentionsContext);\n\n  if (ref.current === null && defaultValue && getInitialHTML) {\n    ref.current = getInitialHTML(defaultValue);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // @ts-ignore\n    divAttributes['data-cy'] = 'input';\n  }\n\n  const mergeOnKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key === 'Enter') {\n      if (onEnter && !opened) {\n        //Because the updates, has to be applied for the event to get the correct value\n        //TODO: Better handling\n        setTimeout(() => {\n          onEnter();\n        }, 200);\n      }\n\n      if (singleLine) {\n        event.preventDefault();\n      }\n    }\n    onKeyDown(event);\n\n    if (divAttributes.onKeyDown) {\n      divAttributes.onKeyDown(event);\n    }\n  };\n\n  const onInput = (event: React.FormEvent<HTMLDivElement>) => {\n    if (divAttributes.onInput) {\n      divAttributes.onInput(event);\n    }\n    onChanges(event);\n  };\n\n  const onBeforeInput = (event: React.FormEvent<HTMLDivElement>) => {\n    onBeforeChanges(event);\n\n    if (divAttributes.onBeforeInput) {\n      divAttributes.onBeforeInput(event);\n    }\n  };\n\n  let style = {\n    outline: 0,\n  };\n  if (singleLine) {\n    style = { ...style, ...{ whiteSpace: 'nowrap', overflow: 'hidden' } };\n  }\n  return (\n    <div\n      ref={setInputElement}\n      {...divAttributes}\n      contentEditable={true}\n      onBeforeInput={onBeforeInput}\n      onKeyDown={mergeOnKeyDown}\n      onInput={onInput}\n      dangerouslySetInnerHTML={{ __html: ref.current || '' }}\n      style={style}\n    ></div>\n  );\n}\n","import React, {\n  FormEvent,\n  KeyboardEvent,\n  useEffect,\n  useState,\n  useRef,\n} from 'react';\n\nimport {\n  initialContext,\n  RichMentionsContext,\n  TMentionItem,\n  TMentionContext,\n  TMentionConfig,\n} from './RichMentionsContext';\n\nimport { getFragment } from './utils/getFragment';\nimport { fixCursorInsertion } from './utils/fixCursorInsertion';\nimport { insertFragment as insertFragmentUtils } from './utils/insertFragment';\nimport { getTransformedValue as getTransformedValueUtils } from './utils/getTransformedValue';\nimport { handleFragmentEscape } from './utils/handleFragmentEscape';\nimport { removeBrokenFragments } from './utils/removeBrokenFragments';\nimport { handleFragmentCreation } from './utils/handleFragmentCreation';\nimport { handleFragmentDeletion } from './utils/handleFragmentDeletion';\nimport { getConfigsInitialValue } from './utils/getConfigsInitialValue';\nimport { transformFinalFragment } from './utils/transformFinalFragment';\nimport { deleteSelection } from './utils/deleteSelection';\n\ninterface TProps<T = object> {\n  children: React.ReactNode | React.ReactNode[];\n  configs: TMentionConfig<T>[];\n  onUpdate?: (value: string) => void;\n  getContext?:\n    | React.MutableRefObject<TMentionContext | null>\n    | ((ref: TMentionContext) => void);\n  getInitialHTML?: (text: string) => string;\n}\n\nexport function RichMentionsProvider<T = object>({\n  children,\n  configs,\n  getContext,\n  onUpdate,\n  getInitialHTML = getConfigsInitialValue(configs),\n}: TProps<T>) {\n  // The reference to always have function context working\n  const ref = useRef<TMentionContext>({\n    ...initialContext,\n    getInitialHTML,\n    setPositionFixed,\n    setInputElement,\n    selectItem,\n    onBeforeChanges,\n    onChanges,\n    onKeyDown,\n    closeAutocomplete,\n    openAutocomplete,\n    setActiveItemIndex,\n    getTransformedValue,\n    insertFragment,\n    setValue,\n  });\n\n  // The state to controls react rendering\n  const [__ctx__, setState] = useState<TMentionContext>(ref.current);\n  const updateState = (data: Partial<TMentionContext>) => {\n    ref.current = {\n      ...ref.current,\n      ...data,\n    };\n    setState(ref.current);\n  };\n\n  // Listen for selection change to open/close the autocomplete modal\n  useEffect(() => {\n    document.addEventListener('selectionchange', onSelectionChange, false);\n    return () => {\n      document.removeEventListener('selectionchange', onSelectionChange, false);\n    };\n  });\n\n  // Expose reference with new context\n  useEffect(() => {\n    if (typeof getContext === 'function') {\n      getContext(__ctx__);\n    } else if (typeof getContext === 'object') {\n      getContext.current = __ctx__;\n    }\n  }, [getContext, __ctx__]);\n\n  /**\n   * Listener to update autocomplete css fixed position\n   * Helpful if you have an input fixed at the top/bottom of your website.\n   *\n   * @param {boolean} fixed Is input element position fixed ? Help to set correct autocomplete position\n   * @returns {void}\n   */\n  function setPositionFixed(fixed: boolean): void {\n    updateState({ fixed });\n  }\n\n  /**\n   * Listener to set new inputElement.\n   * Should be used only by the <InputElement /> to mount/unmount itself\n   *\n   * @param {HTMLDivElement | null} inputElement input element\n   * @returns {void}\n   */\n  function setInputElement(inputElement: HTMLDivElement | null): void {\n    updateState({ inputElement });\n  }\n\n  /**\n   * Called by the autocomplete to select an item.\n   * It will transform the current pending fragment to a final one and\n   * reset the autocomplete\n   *\n   * @param {TMentionItem} item The item from autocomplete to select\n   * @returns {void}\n   */\n  function selectItem(item: TMentionItem<T>): void {\n    const opened = ref.current.opened;\n\n    if (opened?.element) {\n      transformFinalFragment(opened.element, item.ref, opened.config);\n    }\n\n    updateState({\n      index: 0,\n      results: [],\n      opened: null,\n      loading: false,\n      activeSearch: '',\n    });\n  }\n\n  /**\n   * Bounded to input.onBeforeInput event.\n   * Will help to insert/delete/escape fragment before it already happens to avoid a flash\n   *\n   * @param {FormEvent<HTMLDivElement>} event\n   * @returns {void}\n   */\n  function onBeforeChanges(event: FormEvent<HTMLDivElement>): void {\n    let selection = document.getSelection();\n    if (!selection || !selection.anchorNode) {\n      return;\n    }\n\n    // If there is text selection, delete it.\n    // We need to do it manually because of the preventDefault() :'(\n    // Update 'text' variable as the content could be updated\n    if (deleteSelection(selection, event)) {\n      selection = document.getSelection();\n      if (!selection || !selection.anchorNode) {\n        return;\n      }\n    }\n\n    fixCursorInsertion(event, selection);\n    handleFragmentDeletion(event, selection);\n    handleFragmentEscape(event, selection, configs);\n    handleFragmentCreation(event, selection, configs, ref.current);\n    removeBrokenFragments<T>(event.currentTarget, configs);\n  }\n\n  /**\n   * Will handle document.onSelectionChange event\n   * In this case, just to know if wha have focus on a fragment to open/close the autocomplete\n   *\n   * @returns {void}\n   */\n  function onSelectionChange(): void {\n    const {\n      inputElement,\n      opened,\n      closeAutocomplete,\n      openAutocomplete,\n      getTransformedValue,\n    } = ref.current;\n\n    const selection = document.getSelection();\n    const fragment =\n      selection?.anchorNode &&\n      (getFragment(selection.anchorNode) ||\n        (selection.anchorOffset === 0 &&\n          selection.anchorNode.previousSibling &&\n          getFragment(selection.anchorNode.previousSibling)));\n\n    const shouldOpened =\n      fragment &&\n      !fragment.hasAttribute('data-integrity') &&\n      inputElement &&\n      inputElement.contains(fragment);\n\n    if (opened && !shouldOpened) {\n      closeAutocomplete();\n    } else if (\n      shouldOpened &&\n      fragment &&\n      (!opened || opened.element !== fragment)\n    ) {\n      const text = fragment.textContent || '';\n      const config = configs.find(cfg => text.match(cfg.query));\n      if (config) {\n        openAutocomplete(fragment, text, config);\n      }\n    }\n    onUpdate && onUpdate(getTransformedValue());\n  }\n\n  /**\n   * Handle input.onChange event\n   * This part is just to remove broken fragment (let say you removed the \"@\" of a mention) and to\n   * Open/Close autocomplete based on the new cursor position.\n   *\n   * @param {FormEvent<HTMLDivElement>} event\n   * @returns {void}\n   */\n  function onChanges(): void {\n    const { inputElement, openAutocomplete, closeAutocomplete } = ref.current;\n    const selection = document.getSelection();\n\n    if (inputElement) {\n      removeBrokenFragments<T>(inputElement, configs);\n    }\n\n    // Autocomplete\n    const fragment = selection?.anchorNode && getFragment(selection.anchorNode);\n\n    if (fragment && !fragment.hasAttribute('data-integrity')) {\n      const text = fragment.textContent || '';\n      const config = configs.find(cfg => text.match(cfg.query));\n      if (config) {\n        openAutocomplete(fragment, text, config);\n      }\n    } else if (ref.current.opened) {\n      closeAutocomplete();\n    }\n\n    onUpdate && onUpdate(getTransformedValue());\n  }\n\n  /**\n   * Handle input.onKeyDown event\n   * Just to manage the selected item on the autocomplete if opened\n   *\n   * @param {KeyboardEvent<HTMLDivElement>} event\n   * @returns {void}\n   */\n  function onKeyDown(event: KeyboardEvent<HTMLDivElement>): void {\n    const {\n      opened,\n      results,\n      index,\n      selectItem,\n      closeAutocomplete,\n    } = ref.current;\n\n    if (!opened || !results.length) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case 40: // down\n        event.preventDefault();\n        updateState({\n          index: Math.min(index + 1, results.length - 1),\n        });\n        break;\n\n      case 38: // up\n        event.preventDefault();\n        updateState({\n          index: Math.max(index - 1, 0),\n        });\n        break;\n\n      case 9: // tab\n      case 13: // enter\n        if (results[index]) {\n          event.preventDefault();\n          selectItem(results[index]);\n        }\n        break;\n\n      case 27: // escape\n        closeAutocomplete();\n        break;\n    }\n  }\n\n  /**\n   * Public method to close the autocomplete\n   *\n   * @returns {void}\n   */\n  function closeAutocomplete(): void {\n    updateState({\n      opened: null,\n      loading: false,\n      results: [],\n      index: 0,\n      activeSearch: '',\n    });\n  }\n\n  /*\n  function getCaretCoordinates() {\n    let x = 0,\n      y = 0;\n    const isSupported = typeof window.getSelection !== \"undefined\";\n    if (isSupported) {\n      const selection = window.getSelection();\n      if (selection && selection.rangeCount !== 0) {\n        const range = selection.getRangeAt(0).cloneRange();\n        range.collapse(true);\n        const rect = range.getClientRects()[0];\n        if (rect) {\n          x = rect.left;\n          y = rect.top;\n        }\n      }\n    }\n    return { x, y };\n  }\n\n  */\n\n  /**\n   * Public method to open the autocomplete\n   *\n   * @param {HTMLElement} node Selected fragment where to open the autocomplete (for position)\n   * @param {string} text The fragment text we are autocompleting for\n   * @param {TMentionConfig} config The config object linked to the mention\n   * @returns {void}\n   */\n  function openAutocomplete<T>(\n    node: HTMLElement,\n    text: string,\n    config: TMentionConfig<T>\n  ): void {\n    //const fixed = ref.current.fixed;\n    //const rect = { top: 0, right: 0, bottom: 0, left: 0 };\n    let nodeRect = node.getBoundingClientRect();\n    let parentRect = { top: 0, right: 0, bottom: 0, left: 0 }; //node.getBoundingClientRect();\n    //const rects = node.getClientRects();\n\n    if (ref.current.inputElement) {\n      parentRect = ref.current.inputElement.getBoundingClientRect();\n    }\n\n    //const caretPos = getCaretCoordinates();\n    const x = nodeRect.right - parentRect.left;\n    const y = nodeRect.bottom - parentRect.top;\n    /*rect.top = nodeRect.top;\n    rect.right = nodeRect.right;\n    rect.bottom = nodeRect.bottom;\n    rect.left = nodeRect.left;\n\n    // Substract based on relative parent if not position:fixed\n    if (!fixed && node.offsetParent) {\n      const parentRect = node.offsetParent.getBoundingClientRect();\n      rect.top -= parentRect.top;\n      rect.right = rect.right - parentRect.right + parentRect.width;\n      rect.left -= parentRect.left;\n      rect.bottom = rect.bottom - parentRect.bottom + parentRect.height;\n    }\n\n    // TODO ELEMENT_WIDTH and ELEMENT_HEIGHT from Input Autocomplete element\n    const ELEMENT_WIDTH = 200;\n    const ELEMENT_HEIGHT = 300;\n\n    // TODO calculate overflow\n    const overflowX = nodeRect.left + 10 + ELEMENT_WIDTH - window.innerWidth;\n    const overflowY = nodeRect.bottom + ELEMENT_HEIGHT - window.innerHeight;\n\n    const x = 200; //overflowX > 0 ? rect.right + 15 : rect.left - 3;\n    const y = 10;//overflowY > 0 ? rect.top - 3 : rect.bottom + 3;\n    */\n\n    updateState({\n      loading: true,\n      index: 0,\n      opened: {\n        config,\n        fixed: true,\n        bottom: true,\n        right: true,\n        element: node,\n        x,\n        y,\n      },\n      activeSearch: text,\n    });\n\n    const onResolve = (results: TMentionItem[] = []) => {\n      if (ref.current.opened?.element === node) {\n        updateState({\n          results,\n          loading: false,\n        });\n      }\n    };\n\n    const p = config.onMention(text, onResolve);\n    if (p instanceof Promise) {\n      p.then(onResolve, onResolve);\n    } else if (p instanceof Array) {\n      onResolve(p);\n    }\n  }\n\n  /**\n   * Just set the active item in the autocomplete based on the index.\n   * Will work only if autocomplete is already opened\n   *\n   * @param {number} index The active element in autocomplete to hover\n   * @returns {void}\n   */\n  function setActiveItemIndex(index: number): void {\n    updateState({ index });\n  }\n\n  /**\n   * Transform input html content to usable text by transforming the\n   * fragments to valid text and erasing all invalid fragments.\n   *\n   * @returns {string}\n   */\n  function getTransformedValue(): string {\n    return getTransformedValueUtils(ref.current.inputElement);\n  }\n\n  /**\n   * Helper to be able to insert a fragment \"<@test|U211212>\" inside the text\n   *\n   * @param {string} code The code to insert as fragment (preprocess by configs). Ex: \"<@test|U211212>\"\n   * @param {HTMLElement?} element (optional) the html element to insert\n   * @returns {void}\n   */\n  function insertFragment(\n    code: string,\n    element: HTMLElement | null = null\n  ): void {\n    insertFragmentUtils<T>(code, element, configs, ref.current.inputElement);\n  }\n\n  /**\n   * Helper to be able to change the input content externaly\n   *\n   * @param {string} text The text to insert\n   * @returns {void}\n   */\n  function setValue(text: string): void {\n    const { inputElement, closeAutocomplete } = ref.current;\n\n    if (inputElement) {\n      inputElement.innerHTML = getInitialHTML(text);\n      removeBrokenFragments(inputElement, configs);\n    }\n\n    closeAutocomplete();\n  }\n\n  return (\n    <RichMentionsContext.Provider value={__ctx__}>\n      {children}\n    </RichMentionsContext.Provider>\n  );\n}\n","import { TMentionConfig } from './../RichMentionsContext';\nimport { transformFinalFragment } from './transformFinalFragment';\n\nfunction replaceSpacesWithInsecableSpaces(text: string): string {\n  const div = document.createElement('div');\n  div.innerHTML = text;\n\n  function recursiveSpaceReplacer(element: HTMLElement) {\n    Array.from(element.childNodes).forEach(element => {\n      if (element instanceof Text && element.nodeValue) {\n        element.nodeValue = element.nodeValue.replace(/( |\\t)/g, '\\u00A0');\n      } else if (element instanceof HTMLElement) {\n        recursiveSpaceReplacer(element);\n\n        if (\n          element.hasAttribute('data-rich-mentions') &&\n          !element.hasAttribute('data-integrity')\n        ) {\n          element.setAttribute('data-integrity', element.innerHTML);\n        }\n      }\n    });\n  }\n\n  recursiveSpaceReplacer(div);\n\n  return div.innerHTML;\n}\n\nexport function getConfigsInitialValue(configs: TMentionConfig<any>[]) {\n  return (text: string): string => {\n    // This replace all fragment \"<@vince|U515>\" to html ones based on your configs\n    const formattedTextWithHtml = configs.reduce((acc, config) => {\n      return acc.replace(config.match, $0 => {\n        const span = document.createElement('span');\n        transformFinalFragment(span, $0, config);\n        return span.outerHTML;\n      });\n    }, text);\n\n    // We replace all text spaces with unbreakable ones to avoid problem with contenteditable.\n    // Currently, contenteditable remove multiple space but we want to keep it.\n    return replaceSpacesWithInsecableSpaces(formattedTextWithHtml);\n  };\n}\n","import { nodeToHtmlElement } from './nodeToHtmlElement';\nimport { escapeFragmentWithValue } from './escapeFragmentWithValue';\n\nexport function fixCursorInsertion(\n  event: React.FormEvent<HTMLDivElement>,\n  selection: Selection\n): void {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // @ts-ignore\n  const insertion: string = event.data;\n  const container = event.currentTarget;\n\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n\n    // Same element\n    if (range.startContainer === range.endContainer) {\n      const element = nodeToHtmlElement(range.startContainer);\n\n      if (!container.contains(element)) {\n        continue;\n      }\n\n      // If outside pending fragment, insert char inside\n      if (range.startContainer instanceof Text && range.startOffset === 0) {\n        const previousChild = range.startContainer.previousSibling;\n        const previousElement = range.startContainer.previousElementSibling;\n        if (\n          previousChild &&\n          previousElement &&\n          previousChild === previousElement &&\n          previousElement.hasAttribute('data-rich-mentions') &&\n          !previousElement.hasAttribute('data-integrity')\n        ) {\n          previousElement.appendChild(document.createTextNode(insertion));\n          event.preventDefault();\n          continue;\n        }\n      }\n\n      // TODO range.endContainer\n      if (\n        !element ||\n        container === element ||\n        !element.hasAttribute('data-rich-mentions')\n      ) {\n        continue;\n      }\n\n      // At first position of fragment, move before it\n      if (range.endOffset === 0) {\n        escapeFragmentWithValue(element, insertion, 'before');\n        event.preventDefault();\n        continue;\n      }\n\n      const isFinal = element.hasAttribute('data-integrity');\n      const text = element.textContent || '';\n\n      // Move outside final fragment\n      if (isFinal && range.startOffset === text.length) {\n        escapeFragmentWithValue(element, insertion, 'after');\n        event.preventDefault();\n        continue;\n      }\n    }\n  }\n}\n","import { TMentionConfig } from '../RichMentionsContext';\nimport { getFragment } from './getFragment';\nimport { escapeFragmentWithValue } from './escapeFragmentWithValue';\n\nexport function handleFragmentEscape(\n  event: React.FormEvent<HTMLDivElement>,\n  { anchorNode }: Selection,\n  configs: TMentionConfig<any>[]\n) {\n  if (event.defaultPrevented || !anchorNode) {\n    return;\n  }\n\n  const element = getFragment(anchorNode);\n\n  if (element) {\n    // @ts-ignore\n    const insertion: string = event.data;\n    const newText = element.textContent + insertion;\n    const isValid = configs.some(cfg => {\n      const matches = newText.match(cfg.query);\n      return matches && matches[0] === matches.input;\n    });\n\n    if (!isValid) {\n      event.preventDefault();\n      escapeFragmentWithValue(element, insertion);\n    }\n  }\n}\n","import { TMentionConfig, TMentionContext } from '../RichMentionsContext';\nimport { setCursorPosition } from './setCursorPosition';\nimport { getFragment } from './getFragment';\n\nexport function handleFragmentCreation(\n  event: React.FormEvent<HTMLDivElement>,\n  selection: Selection,\n  configs: TMentionConfig<any>[],\n  ctx: TMentionContext\n): void {\n  const { anchorNode, anchorOffset } = selection;\n\n  if (event.defaultPrevented || !anchorNode || getFragment(anchorNode)) {\n    return;\n  }\n\n  // @ts-ignore Find a property type instead of React.FormEvent<HTMLDivElement> ?\n  const insertion: string = event.data;\n  const fragmentText = anchorNode.textContent || '';\n\n  // Build new text fragment with insertion\n  const text =\n    fragmentText.substr(0, anchorOffset) +\n    insertion +\n    fragmentText.substr(anchorOffset);\n\n  // No match\n  const config = configs.find(cfg => text.match(cfg.query));\n  if (!config) {\n    return;\n  }\n\n  const matches = text.match(config.query) as RegExpMatchArray;\n  const index = matches.index || 0;\n  const textBeforeQuery = text.substr(0, index);\n\n  // Do nothing if there is a valid character before.\n  // Do nothing if the range overflow the fragment position\n  if (\n    (textBeforeQuery.length && !/\\W$/.test(textBeforeQuery)) ||\n    anchorOffset < index ||\n    anchorOffset >= index + matches[0].length\n  ) {\n    return;\n  }\n\n  anchorNode.textContent = textBeforeQuery;\n\n  const fragment = document.createElement('span');\n  const textQuery = matches[0].substr(\n    0,\n    anchorOffset - index + insertion.length\n  );\n  const afterInsertion = text.substr(index + textQuery.length);\n\n  fragment.setAttribute('data-rich-mentions', '');\n  fragment.setAttribute('spellcheck', 'false');\n\n  if (process.env.NODE_ENV !== 'production') {\n    fragment.setAttribute('data-cy', 'pending');\n  }\n\n  fragment.textContent = textQuery;\n\n  if (config.customizeFragment) {\n    config.customizeFragment(fragment, false);\n  }\n\n  const after = document.createTextNode(\n    /^\\s/.test(afterInsertion) ? afterInsertion : ' ' + afterInsertion\n  );\n\n  const isContainer = event.currentTarget === anchorNode;\n  const parent = isContainer ? anchorNode : anchorNode.parentElement;\n\n  if (parent) {\n    if (isContainer) {\n      parent.appendChild(fragment);\n      parent.appendChild(after);\n    } else {\n      parent.insertBefore(after, anchorNode.nextSibling);\n      parent.insertBefore(fragment, anchorNode.nextSibling);\n    }\n  }\n\n  event.preventDefault();\n  setCursorPosition(\n    fragment.childNodes[0],\n    anchorOffset - textBeforeQuery.length + 1\n  );\n\n  ctx.openAutocomplete(fragment, textQuery, config);\n}\n","import { TMentionContext } from '../RichMentionsContext';\n\nexport function getTransformedValue(\n  inputElement: TMentionContext['inputElement']\n): string {\n  if (!inputElement || inputElement.innerHTML === '<br>') {\n    return '';\n  }\n\n  const brCharacter = `_br_${Date.now()}_`;\n  const brMatcher = new RegExp(`\\\\n?${brCharacter}\\\\n?`, 'g');\n\n  return Array.from(inputElement.childNodes)\n    .map(el => getNodeContent(el, brCharacter))\n    .join('')\n    .replace(/\\u00A0/g, ' ') // Replace back insecable spaces\n    .replace(/\\n{2,}/g, '\\n') // Following lines are considered as one in HTML\n    .replace(brMatcher, '\\n') // Replace <br/> to line break\n    .trim();\n}\n\nfunction getNodeContent(element: Node, brCharacter: string): string {\n  if (element instanceof Text) {\n    return element.textContent || '';\n  }\n\n  if (element instanceof HTMLBRElement) {\n    return brCharacter;\n  }\n\n  if (element instanceof Element) {\n    const richValue = element.getAttribute('data-rich-mentions');\n    if (richValue) {\n      return richValue;\n    }\n\n    const char = element instanceof HTMLDivElement ? '\\n' : '';\n    const result = Array.from(element.childNodes)\n      .map(el => getNodeContent(el, brCharacter))\n      .join('');\n\n    return `${char}${result}${char}`;\n  }\n\n  return '';\n}\n"],"names":["noop","initialContext","getTransformedValue","insertFragment","setValue","activeSearch","inputElement","setInputElement","selectItem","setActiveItemIndex","opened","index","loading","results","closeAutocomplete","openAutocomplete","onBeforeChanges","onKeyDown","onChanges","fixed","setPositionFixed","RichMentionsContext","createContext","nodeToHtmlElement","node","nodeType","Node","TEXT_NODE","parentElement","getFragment","element","hasAttribute","setCursorPosition","position","selection","document","getSelection","range","createRange","setStart","collapse","removeAllRanges","addRange","escapeFragmentWithValue","text","textNode","createTextNode","replace","parent","insertBefore","nextSibling","length","deleteSelection","event","deleted","lastDeletedRange","i","rangeCount","getRangeAt","startContainer","endContainer","startOffset","endOffset","deleteContents","data","insertNode","preventDefault","transformFinalFragment","span","ref","config","content","match","matchDisplay","textContent","setAttribute","customizeFragment","innerHTML","removeBrokenFragments","configs","Array","from","children","forEach","fixBrokenElement","HTMLBRElement","div","createElement","appendChild","HTMLDivElement","attributes","Text","removeChild","getAttribute","some","cfg","query","isSpace","char","test","needSpaceBefore","offset","defaultValue","charAt","includes","nodeName","previousSibling","prevText","needSpaceAfter","nextText","removeIfFinalFragment","container","contains","className","itemClassName","selectedItemClassName","useContext","onSelectItem","item","onHoverItem","itemAttributes","useEffect","React","style","left","x","top","y","bottom","right","map","type","key","onClick","onMouseOver","name","singleLine","onEnter","divAttributes","useRef","getInitialHTML","current","outline","whiteSpace","overflow","contentEditable","onBeforeInput","setTimeout","onInput","dangerouslySetInnerHTML","__html","getContext","onUpdate","recursiveSpaceReplacer","childNodes","nodeValue","HTMLElement","replaceSpacesWithInsecableSpaces","reduce","acc","$0","outerHTML","getConfigsInitialValue","updateState","anchorNode","defaultPrevented","insertion","currentTarget","previousChild","previousElement","previousElementSibling","fixCursorInsertion","handleFragmentDeletion","newText","matches","input","handleFragmentEscape","ctx","anchorOffset","fragmentText","substr","find","textBeforeQuery","fragment","textQuery","afterInsertion","after","isContainer","handleFragmentCreation","keyCode","Math","min","max","nodeRect","getBoundingClientRect","parentRect","onResolve","p","onMention","Promise","then","code","customFragment","insertAfterNode","insertBeforeNode","addSpaceBefore","addSpaceAfter","firstPart","secondPart","subFragment","firstElementChild","space","insertFragmentUtils","useState","__ctx__","setState","onSelectionChange","shouldOpened","brCharacter","Date","now","brMatcher","RegExp","el","getNodeContent","Element","richValue","join","trim","getTransformedValueUtils","addEventListener","removeEventListener","Provider","value"],"mappings":"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"}